/**
 * @mainpage BitWeaving-lib Documentation
 *
 * @section toc_sec Table of contents
 *
 * <ol>
 *   <li> @ref description_sec
 *   <li> @ref usage_sec
 *   <li> @ref file_layout_sec
 *   <li> @ref api_sec
 *   <ol>
 *     <li> @ref table_sec
 *     <li> @ref column_sec
 *     <li> @ref scan_sec
 *     <li> @ref iter_sec
 *   </ol>
 * </ol>
 *
 * @section description_sec Description
 * The code implements a library for performing efficient scanning queries over column oriented data stores.
 *
 * @section usage_sec Usage
 * To build and run the lib, you need the following packages:
 * <ul>
 *  <li>A modern C++ compiler
 *  <li>Doxygen 1.6 or higher (for generating documentation only)
 * </ul>
 *
 * To write a program using Bitweaving lib, compile Bitweaving lib into a library
 * and link your program with it. Run:
 * @code
 *  $ make
 * @endcode
 * to compile the lib, and generate the lib file libbitweaving.so. Once you are
 * able to compile the bitweaving library, you should link libbitweaving.so into
 * your program, and make sure you have $(BITWEAVING_DIR)/include in the header
 * search path so that the compiler can find all public header files when compiling
 * your program. See $(BITWEAVING_DIR)/examples for some example program to use
 * the bitweaving library.
 *
 * To run unit tests, run:
 * @code
 *  $ make test
 * @endcode
 *
 * Documentation is generated by Doxygen. To generate the documentation, run:
 * @code
 *  $ make doc
 * @endcode
 * Resulting documentation will be placed in the <code>docs/</code> directory;
 * open <code>index.html</code> with your web browser to view it.
 *
 * @section file_layout_sec File layout
 * The files in this package are organized under the following hierarchy:
 * <table border> 
 * <tr> 
 *   <td><b> Directory </b></td> 
 *   <td><b> Description </b></td> 
 * </tr> 
 * <tr> 
 *   <td> \c include/ </td> 
 *   <td> The header files in include directory (include/*.h) contains all public interface to the public callers. </td>
 * </tr>
 * <tr>
 *   <td> \c src/ </td>
 *   <td> The internal implementation of this library is in this directory. The public callers should not include and rely on the header/scource files in this directory. Those internal interfaces may be changed without warnings. </td>
 * </tr>
 * <tr>
 *   <td> \c tests/ </td>
 *   <td> Unit test code. </td>
 * </tr>
 * <tr>
 *   <td> \c examples/ </td>
 *   <td> Some example code showing how to use these public APIs. </td>
 * </tr>
 * <tr>
 *   <td> \c docs/ </td>
 *   <td> Generated documentation. </td>
 * </tr>
 * </table>
 *
 * @section api_sec BitWeaving-lib APIs
 * 
 * @subsection table_sec Creating, opening tables
 * 
 * Tables must first be created and opened before they can be used:
 * @code
 *   // Create a default option to control the file.
 *   bitweaving::Options options = bitweaving::Options();
 *   options.delete_exist_files = true;
 *   // Create a table at $TABLE_DIR_PATH
 *   bitweaving::Table *table = new bitweaving::Table($TABLE_DIR_PATH, options);
 *   // Open the new table
 *   Status status = table->Open();
 * @endcode
 * $TABLE_DIR_PATH is a path of directory in the file system. All associated files for this table will be stored in this directory.
 * Set options.delete_exist_files to clean up all existing files in $TABLE_DIR_PATH to create an empty table.
 *
 * Once the table is created and saved, you can reopen the existing table like so:
 * @code
 *   // Create a default option to control the file.
 *   // The flag options.delete_exist_files is not set by default.
 *   bitweaving::Options options = bitweaving::Options();
 *   // Create a table at $TABLE_DIR_PATH
 *   bitweaving::Table *table = new bitweaving::Table($TABLE_DIR_PATH, options);
 *   // Open an existing table
 *   Status status = table->Open();
 * @endcode
 *
 * @subsection column_sec Adding, loading columns
 *
 * Once the table is opened, you can add columns into this table. For each column, specify column's name and format. 
 * You can pick one format among BitWeaving/H, BitWeaving/V, and a naive columnar format.
 * In addition, you need to specify the size of codes stored in this column in terms of bits. 
 * We use the term "code" to represent an encoded column value. 
 * You need to make a order-preserving scheme to convert the native column value to a code by yourself.
 * @code
 *   // Add a BitWeaving/H column into this table. The code size in this column is 6-bit.
 *   std::size_t code_size = 6;
 *   table->AddColumn("column1", bitweaving::kBitWeavingH, code_size);
 * @endcode
 *
 * To load data into this column, use Column::Append as follows:
 * @code
 *   bitweaving::Code *codes = new bitweaving::Code[num_codes];
 *   // Assign values to codes
 *   ...
 *   // Get column object
 *   bitweaving::Column *column1 = table->GetColumn("column1");
 *   // Insert the codes into this column.
 *   column1->Append(codes, num_codes);
 * @endcode
 *
 * @subsection scan_sec Performing scans on columns
 *
 * A scans is performed on a single column. Before that, you must create bit-vectors to hold the scan results:
 * @code
 *   // Create bitvector
 *   bitweaving::BitVector *bitvector1 = new bitweaving::BitVector(*table);
 * @endcode
 *
 * Now you can run a scan on this column:
 * @code
 *   // Scan the column to find tuples matching predicate "column1 < 10".
 *   column1->Scan(10, bitweaving::kLess, *bitvector1);
 * @endcode
 *
 * If your predicate is a conjunction/disjunction of mutiple basic comparisons, you need to perform scans to evaluate each basic comparison and perform logical AND/OR on these result bit-vectors:
 * @code
 *   // Evaluate column1 < 10 and column2 = 20
 *   column1->Scan(10, bitweaving::kLess, *bitvector1);
 *   // Create another bitvector
 *   bitweaving::BitVector *bitvector2 = new bitweaving::BitVector(*table);
 *   column2->Scan(20, bitweaving::kEqual, *bitvector2);
 *   // Perform logical AND
 *   bitvector1->And(*bitvector2);
 * @endcode
 *
 * It is easier and more efficient to apply logical operations when performing the scan. 
 * Thus, you overwrite the first bit-vector when performing the second scan, and don't need the second bit-vector any more. 
 * @code
 *   // Evaluate "column1 < 10 and column2 = 20"
 *   column1->Scan(10, bitweaving::kLess, *bitvector1);
 *   column2->Scan(20, bitweaving::kEqual, bitweaving::kAnd, *bitvector1);
 * @endcode
 *
 * @subsection iter_sec Fetching matching tuples
 * 
 * All scan results are stored as a bit-vector. To fetch matching tuples in the table, you must create an iterator based on the result bit-vector.
 * @code
 *   // Create an iterator for matching tuples
 *   itweaving::Iterator *iter = new bitweaving::Iterator(*bitvector1);
 * @endcode
 *
 * Now, you can use the iterator to access/update matching tuples:
 * @code
 *   bitweaving::Code code;
 *   while(iter->Next()) {
 *     // Get the next matching value on column1
 *     iter->GetCode(*column1, code);
 *     // More computation on code
 *     ...
 *     // Set the value on column3
 *     iter->SetCode(*column3, code);
 *   }
 * @endcode
 */
